###Minikube on Windows client
#Create a Windows 10/11 machine and enable nested virtualization
#Install Hyper-V
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All
#Download minikube
New-Item -Path 'c:\' -Name 'minikube' -ItemType Directory -Force
Invoke-WebRequest -OutFile 'c:\minikube\minikube.exe' -Uri 'https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe' -UseBasicParsing
#Add to path (start a new powershell session after; if you use Windows Terminal start a new Windows Terminal session altogether)
$oldPath = [Environment]::GetEnvironmentVariable('Path', [EnvironmentVariableTarget]::Machine)
[Environment]::SetEnvironmentVariable('Path', $('{0};C:\minikube' -f $oldPath),[EnvironmentVariableTarget]::Machine)
#Download kubectl (check https://dl.k8s.io/release/stable.txt for latest release)
Invoke-WebRequest -Uri "https://dl.k8s.io/release/v1.22.0/bin/windows/amd64/kubectl.exe" -OutFile 'c:\minikube\kubectl.exe' -UseBasicParsing
#Start the cluster
minikube start
#Test
kubectl get pods -A
#Start and launch the kubernetes dashboard
minikube dashboard
#Create a deployment
kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4
kubectl expose deployment hello-minikube --type=NodePort --port=8080
#Check deployment
kubectl get services hello-minikube
#Have minikube launch a web browser with the service url
minikube service hello-minikube
#Forward the port so you can access it with localhost
kubectl port-forward service/hello-minikube 7080:8080
#Create a load balancer deployment
kubectl create deployment balanced --image=k8s.gcr.io/echoserver:1.4  
kubectl expose deployment balanced --type=LoadBalancer --port=8080
#Start a tunnel in another window
minikube tunnel
#Find the external IP to access to web site
kubectl get services balanced
#Remove the service
kubectl delete service balanced
#Get IP of the minikube VM
minikube ip
#Configure docker client from the host to talk to the docker server in the minikube VM for the current terminal window (on Linux)
eval $(minikube docker-env)


###Manual install of kubernetes infra on centos
#Disable swap on master and worker nodes
swapoff -a
#Comment out the swap line in /etc/fstab

#Install docker on all nodes (check docker version compatibility with k8s)
#Set docker cgroup driver to systemd
sudo nano /etc/docker/daemon.json
#Write#
{
"exec-opts": ["native.cgroupdriver=systemd"]
}
#end#
sudo systemctl daemon-reload
sudo systemctl restart docker
sudo systemctl restart kubelet

#Open firewall ports on master
sudo firewall-cmd --permanent --add-port=6443/tcp
sudo firewall-cmd --permanent --add-port=2379-2380/tcp
sudo firewall-cmd --permanent --add-port=10250/tcp
sudo firewall-cmd --permanent --add-port=10251/tcp
sudo firewall-cmd --permanent --add-port=10252/tcp
sudo firewall-cmd --permanent --add-port=10255/tcp
sudo firewall-cmd --permanent --add-port=8472/udp
sudo firewall-cmd --add-masquerade --permanent
sudo systemctl restart firewalld
#For ubuntu
sudo ufw allow 6443/tcp
sudo ufw allow 2379/tcp
sudo ufw allow 2380/tcp
sudo ufw allow 10250/tcp
sudo ufw allow 10251/tcp
sudo ufw allow 10252/tcp
sudo ufw allow 10255/tcp
sudo ufw allow 8472/udp
sudo ufw default allow FORWARD
sudo service ufw restart

#Open firewall ports on workers
sudo firewall-cmd --permanent --add-port=10250/tcp
sudo firewall-cmd --permanent --add-port=10255/tcp
sudo firewall-cmd --permanent --add-port=8472/udp
sudo firewall-cmd --permanent --add-port=30000-32767/tcp
sudo firewall-cmd --add-masquerade --permanent
sudo systemctl restart firewalld
#For ubuntu
sudo ufw allow 8472/udp
sudo ufw allow 10250/tcp
sudo ufw allow 10255/tcp
sudo ufw allow 30000:32767/tcp
sudo ufw default allow FORWARD
sudo service ufw restart

#Install kubeadm, kubelet and kubectl
#Add the kubernetes repo
sudo nano /etc/yum.repos.d/kubernetes.repo
#Write#
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
#end#
#Set SELinux in permissive mode (effectively disabling it)
sudo setenforce 0
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config
#Install tools
sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
#Enable the kubelet service
sudo systemctl enable --now kubelet
#Set proxy if needed
export HTTP_PROXY=192.168.1.254:80
export HTTPS_PROXY=192.168.1.254:80
export NO_PROXY=localhost,*testcorp.local,192.168.1.247
#Initialize the cluster; networking will be done with flannel in this case (run only on the master)
sudo kubeadm init --pod-network-cidr=10.244.0.0/16
#Run as a normal non root user
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
#Configure network
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
#Check pods
kubectl get pods --all-namespaces

#Install for ubuntu
sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
#The rest is the same as for centos

#Join worker nodes
sudo kubeadm join 192.168.1.247:6443 --token xckfqx.3o9hrwl50pd75y8z --discovery-token-ca-cert-hash sha256:7acb95dab4dc3aa93e31244d8bcdb31ed7ef97ffbc85f28716fde81055f41012

#Check on master that nodes are part of the cluster
kubectl get nodes
#Test kubernetes
kubectl run nginx --image=nginx
kubectl get pods