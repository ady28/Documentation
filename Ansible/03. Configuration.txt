#Create a config file
nano ansible.cfg
#Write
# ansible config file
[defaults]
inventory=./hosts-dev
remote_user=user100
private_key_file=~/.ssh/ansible-key-pair
host_key_checking=False
retry_files_enabled=False
#Test
ansible --list-hosts all
ansible --list-hosts "*"
ansible --list-hosts webservers
ansible --list-hosts app*
ansible --list-hosts webservers:local
ansible --list-hosts \!local
ansible --list-hosts webservers[1]

#User100 should exist on all hosts that will be configured with the same password and sudo passwordless access
#Configure key pair on ansible control host
ssh-keygen -b 2048 -t rsa
chmod 400 .ssh/ansible-key-pair
#Copy key to the configured servers
ssh-copy-id -i ~/.ssh/ansible-key-pair user100@sminion01

#For windows hosts run
ConfigureRemotingForAnsible.ps1 -SkipNetworkProfileCheck
#Create a local user named user100
$sc='pass' | ConvertTo-SecureString -AsPlainText -Force
New-LocalUser user100 -AccountNeverExpires -Password $sc
Add-LocalGroupMember -Group Administrators -Member user100
Set-Item -Path WSMan:\localhost\Service\Auth\Certificate -Value $true
#Generate certificate
$cert=New-SelfSignedCertificate -Type Custom -Subject "CN=user100" -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.2","2.5.29.17={text}upn=user100@localhost") -KeyUsage DigitalSignature,KeyEncipherment -KeyAlgorithm RSA -KeyLength 2048
# Export the public key
$pem_output = @()
$pem_output += "-----BEGIN CERTIFICATE-----"
$pem_output += [System.Convert]::ToBase64String($cert.RawData) -replace ".{64}", "$&`n"
$pem_output += "-----END CERTIFICATE-----"
[System.IO.File]::WriteAllLines("C:\cert.pem", $pem_output)
# Export the private key in a PFX file
[System.IO.File]::WriteAllBytes("C:\cert.pfx", $cert.Export("Pfx"))
#Copy certificate to linux machine (run directly from cmd)
scp C:\cert.pfx user100@192.168.1.250:/home/user100
scp C:\cert.pem user100@192.168.1.250:/home/user100
####Run on the linux machine
openssl pkcs12 -in cert.pfx -nocerts -nodes -out ~/.ssh/cert_key.pem -passin pass: -passout pass:
mv cert.pem .ssh/win_cert.pem
#Import certificate on windows
$cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
$cert.Import("C:\cert.pem")
$store_name = [System.Security.Cryptography.X509Certificates.StoreName]::Root
$store_location = [System.Security.Cryptography.X509Certificates.StoreLocation]::LocalMachine
$store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
$store.Open("MaxAllowed")
$store.Add($cert)
$store.Close()
$cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
$cert.Import("C:\cert.pem")
$store_name = [System.Security.Cryptography.X509Certificates.StoreName]::TrustedPeople
$store_location = [System.Security.Cryptography.X509Certificates.StoreLocation]::LocalMachine
$store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
$store.Open("MaxAllowed")
$store.Add($cert)
$store.Close()
#Map certificate to user
$username = "user100"
$password = ConvertTo-SecureString -String "password" -AsPlainText -Force
$credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $username, $password
# This is the issuer thumbprint which in the case of a self generated cert
# is the public key thumbprint, additional logic may be required for other
# scenarios
$thumbprint = (Get-ChildItem -Path cert:\LocalMachine\root | Where-Object { $_.Subject -eq "CN=user100" }).Thumbprint
New-Item -Path WSMan:\localhost\ClientCertificate -Subject "user100@localhost" -URI * -Issuer $thumbprint -Credential $credential -Force
###The windows host could not be managed with these settings. More testing required